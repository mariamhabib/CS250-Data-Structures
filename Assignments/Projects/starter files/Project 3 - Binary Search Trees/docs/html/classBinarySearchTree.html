<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CS 250 Project 4: Binary Search Tree: BinarySearchTree&lt; TK, TD &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CS 250 Project 4: Binary Search Tree
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classBinarySearchTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BinarySearchTree&lt; TK, TD &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A template binary search tree class.  
 <a href="classBinarySearchTree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BinarySearchTree_8hpp_source.html">BinarySearchTree.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3de2ca8efd1455d1ced09d49828cb75f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#a3de2ca8efd1455d1ced09d49828cb75f">BinarySearchTree</a> ()</td></tr>
<tr class="memdesc:a3de2ca8efd1455d1ced09d49828cb75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the node count to 0, and the root pointer to nullptr.  <a href="#a3de2ca8efd1455d1ced09d49828cb75f">More...</a><br /></td></tr>
<tr class="separator:a3de2ca8efd1455d1ced09d49828cb75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32908378e03fb3dc0c515b65c81c17c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#a32908378e03fb3dc0c515b65c81c17c6">~BinarySearchTree</a> ()</td></tr>
<tr class="memdesc:a32908378e03fb3dc0c515b65c81c17c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the root node.  <a href="#a32908378e03fb3dc0c515b65c81c17c6">More...</a><br /></td></tr>
<tr class="separator:a32908378e03fb3dc0c515b65c81c17c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1214eb6e3d8cfb63f60c6345dc64b31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#ab1214eb6e3d8cfb63f60c6345dc64b31">Insert</a> (const TK &amp;newKey, const TD &amp;newData)</td></tr>
<tr class="memdesc:ab1214eb6e3d8cfb63f60c6345dc64b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new node for the tree and assigns the data of that node to the parameter passed in.  <a href="#ab1214eb6e3d8cfb63f60c6345dc64b31">More...</a><br /></td></tr>
<tr class="separator:ab1214eb6e3d8cfb63f60c6345dc64b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7b6c893bd995f99522866a3cee1f04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#a1b7b6c893bd995f99522866a3cee1f04">Delete</a> (const TK &amp;key)</td></tr>
<tr class="memdesc:a1b7b6c893bd995f99522866a3cee1f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the <a class="el" href="classNode.html" title="A template node class, to be used in the BinarySearchTree class. ">Node</a> that contains the given data, if it exists in the tree.  <a href="#a1b7b6c893bd995f99522866a3cee1f04">More...</a><br /></td></tr>
<tr class="separator:a1b7b6c893bd995f99522866a3cee1f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d99fb23656d7c88ede34373991ce75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#a34d99fb23656d7c88ede34373991ce75">Contains</a> (const TK &amp;key)</td></tr>
<tr class="memdesc:a34d99fb23656d7c88ede34373991ce75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the tree for the key provided and returns true if found, false if not.  <a href="#a34d99fb23656d7c88ede34373991ce75">More...</a><br /></td></tr>
<tr class="separator:a34d99fb23656d7c88ede34373991ce75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91f7e6c512aa0ff6e3d75a1d8cc0746"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#af91f7e6c512aa0ff6e3d75a1d8cc0746">GetInOrder</a> ()</td></tr>
<tr class="memdesc:af91f7e6c512aa0ff6e3d75a1d8cc0746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the keys of the nodes in the tree, in in-order format.  <a href="#af91f7e6c512aa0ff6e3d75a1d8cc0746">More...</a><br /></td></tr>
<tr class="separator:af91f7e6c512aa0ff6e3d75a1d8cc0746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf79ef6e69aa6ac90a9aa69eda5fc2f"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#a5bf79ef6e69aa6ac90a9aa69eda5fc2f">GetPreOrder</a> ()</td></tr>
<tr class="memdesc:a5bf79ef6e69aa6ac90a9aa69eda5fc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the keys of the nodes in the tree, in pre-order format.  <a href="#a5bf79ef6e69aa6ac90a9aa69eda5fc2f">More...</a><br /></td></tr>
<tr class="separator:a5bf79ef6e69aa6ac90a9aa69eda5fc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955641b38b09fad48dff386212b5e692"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#a955641b38b09fad48dff386212b5e692">GetPostOrder</a> ()</td></tr>
<tr class="memdesc:a955641b38b09fad48dff386212b5e692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the keys of the nodes in the tree, in post-order format.  <a href="#a955641b38b09fad48dff386212b5e692">More...</a><br /></td></tr>
<tr class="separator:a955641b38b09fad48dff386212b5e692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadafc04cb0d80f8bb8127bec3617c18"><td class="memItemLeft" align="right" valign="top">TK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#acadafc04cb0d80f8bb8127bec3617c18">GetMax</a> ()</td></tr>
<tr class="memdesc:acadafc04cb0d80f8bb8127bec3617c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest value in the tree.  <a href="#acadafc04cb0d80f8bb8127bec3617c18">More...</a><br /></td></tr>
<tr class="separator:acadafc04cb0d80f8bb8127bec3617c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549c69be4369b93719fabafb10eed383"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#a549c69be4369b93719fabafb10eed383">GetCount</a> ()</td></tr>
<tr class="memdesc:a549c69be4369b93719fabafb10eed383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of nodes in the tree.  <a href="#a549c69be4369b93719fabafb10eed383">More...</a><br /></td></tr>
<tr class="separator:a549c69be4369b93719fabafb10eed383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024149bb1d2b82953d691c6312916c1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#a024149bb1d2b82953d691c6312916c1a">GetHeight</a> ()</td></tr>
<tr class="memdesc:a024149bb1d2b82953d691c6312916c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the height of the entire tree; must be max height.  <a href="#a024149bb1d2b82953d691c6312916c1a">More...</a><br /></td></tr>
<tr class="separator:a024149bb1d2b82953d691c6312916c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07f224e9b68ef681ddec73f0cd6e56e"><td class="memItemLeft" align="right" valign="top">TD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#ad07f224e9b68ef681ddec73f0cd6e56e">GetData</a> (const TK &amp;key)</td></tr>
<tr class="memdesc:ad07f224e9b68ef681ddec73f0cd6e56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data based on a key passed in, or nullptr if not present.  <a href="#ad07f224e9b68ef681ddec73f0cd6e56e">More...</a><br /></td></tr>
<tr class="separator:ad07f224e9b68ef681ddec73f0cd6e56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a46d382c3d81f26edc48a683d98127b43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNode.html">Node</a>&lt; TK, TD &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#a46d382c3d81f26edc48a683d98127b43">FindNode</a> (const TK &amp;key)</td></tr>
<tr class="memdesc:a46d382c3d81f26edc48a683d98127b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Node* that contains the key, or nullptr if data is not in the tree.  <a href="#a46d382c3d81f26edc48a683d98127b43">More...</a><br /></td></tr>
<tr class="separator:a46d382c3d81f26edc48a683d98127b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906da8772ab4d89b68f725a813de5706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNode.html">Node</a>&lt; TK, TD &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#a906da8772ab4d89b68f725a813de5706">FindParentOfNode</a> (const TK &amp;key)</td></tr>
<tr class="memdesc:a906da8772ab4d89b68f725a813de5706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the PARENT Node* of the Node* that contains the key, or nullptr if data is not in the tree.  <a href="#a906da8772ab4d89b68f725a813de5706">More...</a><br /></td></tr>
<tr class="separator:a906da8772ab4d89b68f725a813de5706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7ae8df7f28600e52fc18283ac74d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#abc7ae8df7f28600e52fc18283ac74d4e">RecursiveInsert</a> (const TK &amp;newKey, const TD &amp;newData, <a class="el" href="classNode.html">Node</a>&lt; TK, TD &gt; *ptrCurrent)</td></tr>
<tr class="memdesc:abc7ae8df7f28600e52fc18283ac74d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recurses through the tree and finds the proper location for the new data.  <a href="#abc7ae8df7f28600e52fc18283ac74d4e">More...</a><br /></td></tr>
<tr class="separator:abc7ae8df7f28600e52fc18283ac74d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32eaf601ac4c20a71c818f905e20e2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#ae32eaf601ac4c20a71c818f905e20e2e">GetInOrder</a> (<a class="el" href="classNode.html">Node</a>&lt; TK, TD &gt; *ptrCurrent, stringstream &amp;stream)</td></tr>
<tr class="memdesc:ae32eaf601ac4c20a71c818f905e20e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recurses through the tree in IN-ORDER order, writing to the stream.  <a href="#ae32eaf601ac4c20a71c818f905e20e2e">More...</a><br /></td></tr>
<tr class="separator:ae32eaf601ac4c20a71c818f905e20e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67bb354708055152757d27d99d569bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#ae67bb354708055152757d27d99d569bb">GetPreOrder</a> (<a class="el" href="classNode.html">Node</a>&lt; TK, TD &gt; *ptrCurrent, stringstream &amp;stream)</td></tr>
<tr class="memdesc:ae67bb354708055152757d27d99d569bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recurses through the tree in PRE-ORDER order, writing to the stream.  <a href="#ae67bb354708055152757d27d99d569bb">More...</a><br /></td></tr>
<tr class="separator:ae67bb354708055152757d27d99d569bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c97fbe7406de99a7c6d90247eb47c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#ab6c97fbe7406de99a7c6d90247eb47c3">GetPostOrder</a> (<a class="el" href="classNode.html">Node</a>&lt; TK, TD &gt; *ptrCurrent, stringstream &amp;stream)</td></tr>
<tr class="memdesc:ab6c97fbe7406de99a7c6d90247eb47c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recurses through the tree in POST-ORDER order, writing to the stream.  <a href="#ab6c97fbe7406de99a7c6d90247eb47c3">More...</a><br /></td></tr>
<tr class="separator:ab6c97fbe7406de99a7c6d90247eb47c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2792ab45f6037873d8d73b2bcfa40d8f"><td class="memItemLeft" align="right" valign="top">TK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#a2792ab45f6037873d8d73b2bcfa40d8f">GetMax</a> (<a class="el" href="classNode.html">Node</a>&lt; TK, TD &gt; *ptrCurrent)</td></tr>
<tr class="memdesc:a2792ab45f6037873d8d73b2bcfa40d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recurses through the tree, going to the right-child-nodes until the max key is found.  <a href="#a2792ab45f6037873d8d73b2bcfa40d8f">More...</a><br /></td></tr>
<tr class="separator:a2792ab45f6037873d8d73b2bcfa40d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e871429a131d331b831334d57888211"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#a0e871429a131d331b831334d57888211">GetHeight</a> (<a class="el" href="classNode.html">Node</a>&lt; TK, TD &gt; *ptrCurrent)</td></tr>
<tr class="separator:a0e871429a131d331b831334d57888211"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a721f28bd510e040b8573bdb1a19744ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNode.html">Node</a>&lt; TK, TD &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#a721f28bd510e040b8573bdb1a19744ba">m_ptrRoot</a></td></tr>
<tr class="memdesc:a721f28bd510e040b8573bdb1a19744ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the root node of the tree; TK = data type of the key, TD = data type of the data.  <a href="#a721f28bd510e040b8573bdb1a19744ba">More...</a><br /></td></tr>
<tr class="separator:a721f28bd510e040b8573bdb1a19744ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619940c056dcb8aa8246ada1e7ca2e2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#a619940c056dcb8aa8246ada1e7ca2e2c">m_nodeCount</a></td></tr>
<tr class="memdesc:a619940c056dcb8aa8246ada1e7ca2e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The amount of nodes in the tree.  <a href="#a619940c056dcb8aa8246ada1e7ca2e2c">More...</a><br /></td></tr>
<tr class="separator:a619940c056dcb8aa8246ada1e7ca2e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8da748c2b0afd5c6b23e931591f217de"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinarySearchTree.html#a8da748c2b0afd5c6b23e931591f217de">Tester</a></td></tr>
<tr class="separator:a8da748c2b0afd5c6b23e931591f217de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TK, typename TD&gt;<br />
class BinarySearchTree&lt; TK, TD &gt;</h3>

<p>A template binary search tree class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3de2ca8efd1455d1ced09d49828cb75f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::<a class="el" href="classBinarySearchTree.html">BinarySearchTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the node count to 0, and the root pointer to nullptr. </p>

</div>
</div>
<a class="anchor" id="a32908378e03fb3dc0c515b65c81c17c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::~<a class="el" href="classBinarySearchTree.html">BinarySearchTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the root node. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a34d99fb23656d7c88ede34373991ce75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::Contains </td>
          <td>(</td>
          <td class="paramtype">const TK &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the tree for the key provided and returns true if found, false if not. </p>
<dl class="section return"><dt>Returns</dt><dd>&lt;bool&gt; whether or not the key is found in the tree. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b7b6c893bd995f99522866a3cee1f04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::Delete </td>
          <td>(</td>
          <td class="paramtype">const TK &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the <a class="el" href="classNode.html" title="A template node class, to be used in the BinarySearchTree class. ">Node</a> that contains the given data, if it exists in the tree. </p>
<p>Search the tree for a <a class="el" href="classNode.html" title="A template node class, to be used in the BinarySearchTree class. ">Node</a> that contains the data. This <a class="el" href="classNode.html" title="A template node class, to be used in the BinarySearchTree class. ">Node</a> will be removed.</p>
<p>You must handle children of the node based on how many it has.</p>
<p>See the Sherrod attachment for the detailed code, page 310 - 312.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>const TK&amp;, the data to be removed from the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;void&gt; </dd></dl>

</div>
</div>
<a class="anchor" id="a46d382c3d81f26edc48a683d98127b43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a>&lt;TK, TD&gt;* <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::FindNode </td>
          <td>(</td>
          <td class="paramtype">const TK &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Node* that contains the key, or nullptr if data is not in the tree. </p>
<p>Similar to the Contains function, you will have to traverse the tree to find the key. If you find the <a class="el" href="classNode.html" title="A template node class, to be used in the BinarySearchTree class. ">Node</a> that contains this data, you will return the Node*.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>&lt;const TK&amp;&gt;, the key that we are searching for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;Node&lt;T&gt;*&gt; the Node* that contains the key. Otherwise, nullptr if data is not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a906da8772ab4d89b68f725a813de5706"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a>&lt;TK, TD&gt;* <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::FindParentOfNode </td>
          <td>(</td>
          <td class="paramtype">const TK &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the PARENT Node* of the Node* that contains the key, or nullptr if data is not in the tree. </p>
<p>Similar to the FindNode function, you will instead return the PARENT NODE of the node that contains the key, rather than the node itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>&lt;const TK&amp;&gt;, the key we are searching for; but going to return the parent of this node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;Node&lt;TK, TD&gt;*&gt; the Node* that contains the data. Otherwise, nullptr if key is not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a549c69be4369b93719fabafb10eed383"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::GetCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the amount of nodes in the tree. </p>
<dl class="section return"><dt>Returns</dt><dd>&lt;int&gt; the amount of nodes in the tree </dd></dl>

</div>
</div>
<a class="anchor" id="ad07f224e9b68ef681ddec73f0cd6e56e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TD* <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::GetData </td>
          <td>(</td>
          <td class="paramtype">const TK &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data based on a key passed in, or nullptr if not present. </p>
<p>Search the binary tree for the node that has the given key (can use the FindNode function), and returns the data associated with that node. If no node is found, return nullptr instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>&lt;TK&amp;&gt; the key of the node we're searching for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;TD*&gt; data of the node that has the key given </dd></dl>

</div>
</div>
<a class="anchor" id="a024149bb1d2b82953d691c6312916c1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::GetHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the height of the entire tree; must be max height. </p>
<dl class="section return"><dt>Returns</dt><dd>&lt;int&gt; height of the tree </dd></dl>

</div>
</div>
<a class="anchor" id="a0e871429a131d331b831334d57888211"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::GetHeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; TK, TD &gt; *&#160;</td>
          <td class="paramname"><em>ptrCurrent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the height of left sub tree, say leftHeight Get the height of right sub tree, say rightHeight Take the Max(leftHeight, rightHeight) and add 1 for the root and return Call recurÂ­sively. </p>

</div>
</div>
<a class="anchor" id="af91f7e6c512aa0ff6e3d75a1d8cc0746"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::GetInOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Displays the keys of the nodes in the tree, in in-order format. </p>
<p>This function creates a stringstream and calls the recursive GetInOrder function. It will return the keys of the nodes in the tree in string format.</p>
<dl class="section return"><dt>Returns</dt><dd>&lt;string&gt; The keys of the nodes in the tree, in in-order format, as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="ae32eaf601ac4c20a71c818f905e20e2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::GetInOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; TK, TD &gt; *&#160;</td>
          <td class="paramname"><em>ptrCurrent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stringstream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recurses through the tree in IN-ORDER order, writing to the stream. </p>
<p>In order will display the items in the tree in ascending order. From an algorithmic point of view, for whatever node it is on, it will:</p><ul>
<li>Display the left node item</li>
<li>Display the current node item</li>
<li>Display the right node item</li>
</ul>
<p>To write out to the stream, simply use: stream &lt;&lt; ptrCurrent-&gt;key &lt;&lt; " ";</p>
<p>Note that it is expected that you will have a leading space " " at the end of the generated string. </p>

</div>
</div>
<a class="anchor" id="acadafc04cb0d80f8bb8127bec3617c18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TK* <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::GetMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the largest value in the tree. </p>
<p>Keep in mind that, for any given node, anything to the RIGHT is greater than that node.</p>
<dl class="section return"><dt>Returns</dt><dd>&lt;TK*&gt; Largest key in the tree, or nullptr if tree is empty </dd></dl>

</div>
</div>
<a class="anchor" id="a2792ab45f6037873d8d73b2bcfa40d8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TK* <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::GetMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; TK, TD &gt; *&#160;</td>
          <td class="paramname"><em>ptrCurrent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recurses through the tree, going to the right-child-nodes until the max key is found. </p>
<p>Items are inserted into a binary search tree in a sorted order. This means that larger items always get inserted to the right, with the maximum value being the right-most value. </p>

</div>
</div>
<a class="anchor" id="a955641b38b09fad48dff386212b5e692"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::GetPostOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Displays the keys of the nodes in the tree, in post-order format. </p>
<p>This function creates a stringstream and calls the recursive GetPostOrder function. It will return the keys of the nodes in the tree in string format.</p>
<dl class="section return"><dt>Returns</dt><dd>&lt;string&gt; The keys of the nodes in the tree, in post-order format, as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6c97fbe7406de99a7c6d90247eb47c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::GetPostOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; TK, TD &gt; *&#160;</td>
          <td class="paramname"><em>ptrCurrent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stringstream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recurses through the tree in POST-ORDER order, writing to the stream. </p>
<p>In order will display the items in the tree post-order. From an algorithmic point of view, for whatever node it is on, it will:</p><ul>
<li>Display the left node item</li>
<li>Display the right node item</li>
<li>Display the current node item</li>
</ul>
<p>Note that it is expected that you will have a leading space " " at the end of the generated string. </p>

</div>
</div>
<a class="anchor" id="a5bf79ef6e69aa6ac90a9aa69eda5fc2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::GetPreOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Displays the keys of the nodes in the tree, in pre-order format. </p>
<p>This function creates a stringstream and calls the recursive GetPreOrder function. It will return the keys of the nodes in the tree in string format.</p>
<dl class="section return"><dt>Returns</dt><dd>&lt;string&gt; The keys of the nodes in the tree, in pre-order format, as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="ae67bb354708055152757d27d99d569bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::GetPreOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; TK, TD &gt; *&#160;</td>
          <td class="paramname"><em>ptrCurrent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stringstream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recurses through the tree in PRE-ORDER order, writing to the stream. </p>
<p>In order will display the items in the tree pre-order. From an algorithmic point of view, for whatever node it is on, it will:</p><ul>
<li>Display the current node item</li>
<li>Display the left node item</li>
<li>Display the right node item</li>
</ul>
<p>Note that it is expected that you will have a leading space " " at the end of the generated string. </p>

</div>
</div>
<a class="anchor" id="ab1214eb6e3d8cfb63f60c6345dc64b31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::Insert </td>
          <td>(</td>
          <td class="paramtype">const TK &amp;&#160;</td>
          <td class="paramname"><em>newKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TD &amp;&#160;</td>
          <td class="paramname"><em>newData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new node for the tree and assigns the data of that node to the parameter passed in. </p>
<p>If the tree is empty, the new data goes at the root node. Otherwise, we will have to recurse through the tree in order to find the correct position for our new data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newKey</td><td>const TK&amp;, the key to index this new item under </td></tr>
    <tr><td class="paramname">newData</td><td>const TD&amp;, the new data to be added to the tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;void&gt; </dd></dl>

</div>
</div>
<a class="anchor" id="abc7ae8df7f28600e52fc18283ac74d4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::RecursiveInsert </td>
          <td>(</td>
          <td class="paramtype">const TK &amp;&#160;</td>
          <td class="paramname"><em>newKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TD &amp;&#160;</td>
          <td class="paramname"><em>newData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; TK, TD &gt; *&#160;</td>
          <td class="paramname"><em>ptrCurrent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recurses through the tree and finds the proper location for the new data. </p>
<p>TERMINATING CASE: If ptrCurrent is a nullptr, then we have traversed to a space that is available for our new node. Create our new node here and set up the data.</p>
<p>RECURSIVE CASE: If ptrCurrent is already taken, we must figure out whether to recurse LEFT or RIGHT, based on the value of newData compared to the prtCurrent's data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newKey</td><td>const TK&amp;, the key to index this new item under </td></tr>
    <tr><td class="paramname">newData</td><td>const TD&amp;, the new data to be added to the tree </td></tr>
    <tr><td class="paramname">ptrCurrent</td><td>Node&lt;TK, TD&gt;*, the pointer to the current root of a subtree; will traverse left or right if newKey is less-than or greater-than, respectively. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;void&gt; </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a8da748c2b0afd5c6b23e931591f217de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classTester.html">Tester</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a619940c056dcb8aa8246ada1e7ca2e2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::m_nodeCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The amount of nodes in the tree. </p>

</div>
</div>
<a class="anchor" id="a721f28bd510e040b8573bdb1a19744ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TK, typename TD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a>&lt;TK, TD&gt;* <a class="el" href="classBinarySearchTree.html">BinarySearchTree</a>&lt; TK, TD &gt;::m_ptrRoot</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the root node of the tree; TK = data type of the key, TD = data type of the data. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="BinarySearchTree_8hpp_source.html">BinarySearchTree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
